#!/usr/bin/env python3
# encoding: utf-8
# Copyright (C) 2023 John TÃ¶rnblom
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING. If not see
# <http://www.gnu.org/licenses/>.

import argparse
import logging
import os
import xml.etree.ElementTree as ET

from pathlib import Path
from elftools.elf.elffile import ELFFile


logger = logging.getLogger('trampgen')


# read NIDs from nid_db.xml
NID_DB = (os.path.dirname(__file__) or '.') + '/nid_db.xml'
nid_map = {entry.get('obf'): entry.get('sym')
           for entry in ET.parse(NID_DB).getroot()}



def symbols(sym_type, filename, library_index):
    '''
    yield symbol names in PT_DYNAMIC segments using the NID lookup table
    'nid_db.xml'.
    '''
    with open(filename, 'rb') as f:
        elf = ELFFile(f)

        for segment in elf.iter_segments():
            if segment.header.p_type != 'PT_DYNAMIC':
                continue

            for sym in segment.iter_symbols():
                if sym_type != sym.entry['st_info']['type']:
                    continue

                if sym.entry['st_shndx'] == 'SHN_UNDEF':
                    continue

                if not sym.name:
                    continue

                nid, lid, mid = sym.name.split('#')
                if library_index != lid:
                    continue

                if not nid in nid_map:
                    logger.warning(f'skipping unknown NID {nid}')
                    continue

                yield nid_map[nid]


if __name__ == '__main__':
    logging.basicConfig(level=logging.WARNING)

    parser = argparse.ArgumentParser()
    parser.add_argument('--prx', required=True)
    parser.add_argument('--library-index', required=True)

    cli_args = parser.parse_args()

    basename = os.path.basename(cli_args.prx)
    funcs = sorted(symbols('STT_FUNC', cli_args.prx, cli_args.library_index))
    gvars = sorted(symbols('STT_OBJECT', cli_args.prx, cli_args.library_index))

    print('// This file was generated by trampgen.py, do not edit manually!')
    print('')

    # declare external dependencies
    print('int sceKernelDlsym(int, const char*, void*);')
    print('int sceKernelLoadStartModule(const char*, unsigned long, const void*, unsigned int, void*, int*);')
    print('int sceKernelStopUnloadModule(int, unsigned long, const void*, unsigned int, const void*, int*);')
    print('')

    # define constructor and destructor
    if basename in ('libkernel.sprx', 'libkernel_sys.sprx', 'libkernel_web.sprx'):
        print('static int __module_id = 0x2001;')
        print('')
    else:
        print('static int __module_id = 0;')
        print('')
        print('static void __attribute__((constructor(102)))')
        print('__init() {')
        print(f'  __module_id = sceKernelLoadStartModule("{basename}", 0, 0, 0, 0, 0);')
        print('}')
        print('')
        print('static void __attribute__((destructor(102)))')
        print('__fini() {')
        print(f'  sceKernelStopUnloadModule(__module_id, 0, 0, 0, 0, 0);')
        print('}')
        print('')
    
    # declare functions
    for sym in funcs:
        if sym in ('sceKernelDlsym', 'sceKernelLoadStartModule',
                   'sceKernelStopUnloadModule'):
            continue

        print('asm(".intel_syntax noprefix\\n"')
        print(f'    ".global {sym}\\n"')
        print(f'    ".type {sym} @function\\n"')
        print(f'    "{sym}:\\n"')
        print(f'    "jmp qword ptr [rip + __ptr_{sym}]\\n");')
        print()
        print('asm(".intel_syntax noprefix\\n"')
        print(f'    ".type __load_and_call_{sym} @function\\n"')
        print(f'    "__load_and_call_{sym}:\\n"')
        print('    "push rdi\\n"')
        print('    "push rsi\\n"')
        print('    "push rdx\\n"')
        print('    "push rcx\\n"')
        print('    "push r8\\n"')
        print('    "push r9\\n"')
        print(f'    "call __load_{sym}\\n"')
        print('    "pop r9\\n"')
        print('    "pop r8\\n"')
        print('    "pop rcx\\n"')
        print('    "pop rdx\\n"')
        print('    "pop rsi\\n"')
        print('    "pop rdi\\n"')
        print(f'    "jmp qword ptr [rip + __ptr_{sym}]\\n");')
        print('')
        print(f'void __load_and_call_{sym}();')
        print(f'static __attribute__ ((used)) void* __ptr_{sym} = &__load_and_call_{sym};')
        print('')
        print('static __attribute__ ((used)) void')
        print(f'__load_{sym}() ' + '{')
        print(f'  if(sceKernelDlsym(__module_id, "{sym}", &__ptr_{sym}))' + ' {')
        print('    __builtin_trap();')
        print('  }')
        print('}')
        print('')

